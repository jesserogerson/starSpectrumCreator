#!/usr/bin/env python3
'''
--------------------------------------------------------------------------------
Author: Jesse A. Rogerson, York University, jesserogerson.com, rogerson@yorku.ca

Additional credits:

1. Advice provided by Geoff Matthews, mathewsgeoff@fhda.edu, for line lists of
multiple elements.

DESCRIPTION:
----------
This script randomly generates stellar spectra and randomly puts the absorption
features of various elements on that spectra.

LEARNING GOALS:
----------
This script was developed for use in NATS1740, an introductory astronomy course
for non-science majors at York University, Toronto. The students who take NATS
courses at YorkU come from a wide variety of academic backgrounds, mostly with
little-to-no scientific experience.

The following learning outcomes influenced the building this script, and the
project associated with it:
- working with graphs, X-axis, Y-axis, reading values
- working with spectra in graph-form (as opposed to the 'rainbow'-form)
- comfort with the type of light stars produce across the EM spectrum, the
  difference between UV, Visible, and Infrared, specifically
- how temperature affects the full spectrum of light from a star
- what an absorption feature is, and how to identify a specific element
- what an emission feature is, and how to identify a specific element
- understand how relative motion affects the absorption/emission pattenrs via
  the doppler effect

FOR HELP:
----------

$> ./ starSpectrumCreator.py -h

usage: starSpectrumCreator.py [-h] [-out OUT] studentList.csv

positional arguments:
studentList.csv     /path/to/list/of/students. Must be a CSV file,
                    with column 1: student number, column 2: last name,
                    column 3: first name. More columns are fine,
                    they wont be used.

optional arguments:
  -h, --help        show this help message and exit
  -out OUT          Two output files are always created, with prefixes
                    'ANSWERS_' and 'STUDENT_'. This argument allows you to
                    specify the root/suffix of those two PDFs.
                    The default is: randomStarSpectra.pdf

OUTPUTS:
----------
The output of this script is two PDFs: one to give to the student, and one to
give to the Professor/TA/Teaching Team (the latter contains answers).

The script generates a unique spectrum for each student in the class, given the
list of students provided in CSV format, and then creates the following files:

1. STUDENT_[randomStarSpectra.pdf] - meant to be handed directly to the student
2. ANSWERS_[randomStarSpectra.pdf] - meant to be kept for grading purposes.

(note that [randomStarSpectra.pdf] can be changed by the user running the script)

In the STUDENT_[randomStarSpectra.pdf], each student corresponds to one page
in the output PDF. On each page, there are two figures:

Figure 1: a full blackbody spectrum of their star, generated by randomly
selecting a temperature between 2400 < T (K) < 30,000. Absorption patterns are
are randomly chosen and placed on the spectrum, in the visible portion of the
electromagnetic spectrum. They are difficult to see, as Figure 1 is zoomed out.

Figure 2: a zoom-in on the 400nm to 700nm portion of the star's electromagnetic
spectrum, so that students may better see the absorption pattern

Each star's spectrum has a random temperature and a random set of
absorption features. The STUDENT_ PDF also contains additional information the
student may need to answer questions.

In the ANSWERS_[randomStarSpectra.pdf], everything is the exact same, but with
some additional information:
a) Figure 1's title contains the random temperature used to create the spectrum
b) Figure 1 has a label pointing to the peak intensity, and the wavelength at
   which it occurs
c) Figure 2's title contains the elements used to create the absorption pattern

This additional information is used for grading purposes.

NOTES:
----------
a) The absorption pattern is randomly selected from an internal set of common
elements. Therefore, the elements that create the absorption patterns seen in
the outputted spectra do not match the known elements found in each spectral
type. Consult the following to see what are the common elements found in each
spectral type spectra:

- Table 17.3, Astronomy 2e, Opentext
https://openstax.org/books/astronomy-2e/pages/17-3-the-spectra-of-stars-and-brown-dwarfs

- University of Nebraska-Lincoln. (2023). Spectroscopic Parallax Simulator
https://astro.unl.edu/classaction/animations/stellarprops/spectroparallax.html

b) The line list and intensities of those lines are not entirely real, they are
based on both coversations with Geoff Mathews and the data found at:
https://physics.nist.gov/PhysRefData/Handbook/Tables/heliumtable1_a.htm

However, for ease of use, only some lines were chosen and their intensities have
been adjusted to see them better. Since this script is meant for teaching
purposes (and should never be used for any research applications), it focusses
on concepts, not accuracy.

c)FUTURE Ideas:
- make it possible for the user to choose the elements via optional arguments.
- use the correct elements for the absorption patterns depending on spectral type
- have absorption patterns extend across the UV, visible, and infrared


HISTORY
--------------------------------------------------------------------------------
2023-11-03 - JAR - created
2023-11-13 - JAR - used ChatGPT to update/adjust the code. Solved some bugs and
                   unit transfer issues.
2023-11-15 - JAR - added in absorption lines
2023-11-29 - JAR - added a large amount of comments
                 - added in optional argument -out OUT, which allows user to
                   to specify the name of the output PDFs
--------------------------------------------------------------------------------
'''
import numpy as np
from matplotlib.backends.backend_pdf import PdfPages
import matplotlib.pyplot as plt
from scipy.constants import h, c, k
import argparse
import random
import csv
import sys

# Constants
h = h  # Planck's constant
c = c  # Speed of light
k = k  # Boltzmann constant
wien_constant = 2.897e6  # Wien's displacement constant in nm * Kelvin

H_lines=[410.2, 434.0, 486.1, 656.3]
H_depth=[0.25,0.25,0.5,0.9]

He_lines=[447.1, 471.3, 492.2, 501.6, 587.6, 667.8]
He_depth=[0.75,0.20,0.25,0.65,0.9,0.9]

Li_lines=[468, 479, 548.4, 610.3, 670.8]
Li_depth=[0.1,0.1,0.1,0.5,0.9]

Na_lines=[439.3, 445.5, 449.1, 589, 589.6]
Na_depth=[0.1,0.1,0.1,0.9,0.9]

Hg_lines=[404.7, 435.8, 546.1, 577, 579.1]
Hg_depth=[0.75,0.9,0.9,0.5,0.5]

Ne_lines=[540.1, 585.2, 588.2, 603, 607.4, 616.4, 621.7, 626.6, 633.4, 638.3, 640.2, 650.6, 659.9, 692.9]
Ne_depth=[0.05, 0.5, 0.25, 0.25, 0.5, 0.75, 0.25, 0.25, 0.25, 0.25, 0.25, 1, 0.5, 0.5]

N_lines=[480.3, 496.3, 575.2, 593.1]
N_depth=[0.25,0.5,0.15,0.7]

C_lines=[426.7,514.5,515.1,658.2]
C_depth=[0.5,0.5,0.6,0.7]

O_lines=[407.2,418.5,441.4,464.9,616.5]
O_depth=[0.1,0.2,0.5,0.1,0.8]

Fe_lines=[428.2,438.3,495.7,516.7,526.9,645.6]
Fe_depth=[0.6,0.7,0.25,0.35,0.1,0.2]

#atomic line list Dictionary
LineListDict={'Hydrogen':[H_lines,H_depth],'Helium':[He_lines,He_depth],'Lithium':[Li_lines,Li_depth],'Sodium':[Na_lines,Na_depth],'Mercury':[Hg_lines,Hg_depth],'Neon':[Ne_lines,Ne_depth],'Nitrogen':[N_lines,N_depth],'Carbon':[C_lines,C_depth],'Oxygen':[O_lines,O_depth],'Iron':[Fe_lines,Fe_depth]}


#defining the Black Body Spectrum of the stars
def planck(wavelength, T):
    """
    Function to calculate the blackbody radiation intensity for a given wavelength and temperature.

    There is a way to do this using the astropy library, however, I couldn't
    easily figure it out, so I just created the Planck function from scratch.

    Here's the link to the astropy blackbody model

    Future goal: get this working instead.
    https://docs.astropy.org/en/stable/api/astropy.modeling.physical_models.BlackBody.html
    """
    exponent = h * c / (wavelength * k * T)
    # this approximation was required because I kept getting errors when the
    # exponent was large.
    if exponent > 100:
        intensity = 0.0  # Approximate very large exponent as zero intensity
    else:
        intensity = (2 * h * c**2 / wavelength**5) / (np.exp(exponent) - 1)
    return intensity

def createSpectrum(student):
    '''
    Function to create a PDF containing spectrum and other pertinent
    information for each student.
    Calls planck() when needed.
    '''
    # print(student[0],student[1],student[2],student[3])

    # Step 1 - First randomly generate a Temperature
    temperature=random.randint(2400,30000) # in Kelvin
    temperature=round(temperature,-2) # I only need it to be to the closest hundred

    # Step 2 - Define the wavelength range
    wavelengths = np.linspace(1, 2000, 2000)  # in nanometers
    # Convert wavelengths to meters for calculation
    wavelengths_m = wavelengths * 1e-9  # convert nanometers to meters

    # Step 3 - Choose 3 random elements
    # this creates a LIST of 3 elements, randomly taken from the LineListDict
    random_Lines = random.sample(list(LineListDict.keys()),3)

    # Step 4 - call planck(), sending the randomly generated temperature value
    # and the wavelength range
    intensities = [planck(wavelength, temperature) for wavelength in wavelengths_m]

    # Step 5 - Find the wavelength of peak intensity
    # This is done, so that it can be printed on the ANSWERS version, as students
    # are asked to measure this themselves off their graph by hand
    wavelength_peak = wavelengths[np.argmax(intensities)]
    # print(wavelength_peak) # for validation

    # Step 6 - Calculate the temperature using Wien's Law
    calculated_temperature = wien_constant / wavelength_peak
    # print(calculated_temperature) # for validation

    # Step 7 - apply the absorption patterns
    # this is done by starting with the random element, then indexing through
    # the wavelengths array until you find the right spot, then applying the
    # 'intensity' value.
    # FUTURE: this should be its own function.
    for key in random_Lines:
        lines=LineListDict[key][0]
        depth=LineListDict[key][1]
        print(key)
        print(lines)
        print(depth)

        for index,l in enumerate(lines):
            for i in range(len(wavelengths)):
                if wavelengths[i]>=l-0.5 and wavelengths[i]<=l+0.5:
                    intensities[i]=intensities[i]*(1-depth[index])

    # Step 8 - Output
    # This portion creates two PDF objects
    # figStudent - for handing out to the student
    # figProfessor - for handing out to Prof/TAs, contains some of the answers.

    # Create the figure and axis objects
    figStudent, (ax1s, ax2s) = plt.subplots(2, 1, figsize=(8, 10), gridspec_kw={'height_ratios': [1, 1]})
    figProfessor, (ax1p, ax2p) = plt.subplots(2, 1, figsize=(8, 10), gridspec_kw={'height_ratios': [1, 1]})

    # Plot for STUDENT
    # Plot the blackbody spectrum in the top subplot
    ax1s.plot(wavelengths, intensities, color='black')
    ax1s.set_title('Student: {}. Figure 1 - Spectrum'.format(student[0]))
    ax1s.set_xlabel('Wavelength (nm)')
    ax1s.set_ylabel('Intensity') # (W/sr/m^3)
    ax1s.grid(True)
    ax1s.set_xticks(np.arange(min(wavelengths)-1, max(wavelengths), 200))

    ax2s.plot(wavelengths,intensities,color='black')
    ax2s.set_title('Student: {}. Figure 2 - Absorption pattern'.format(student[0]))
    ax2s.set_xlabel('Wavelength (nm)')
    ax2s.set_ylabel('Intensity')
    ax2s.set_xlim([390,710])
    ax2s.grid(True)
    visy=[]
    for index,lam in enumerate(wavelengths):
        if lam>390 and lam<710:
            visy.append(intensities[index])
    ax2s.set_ylim(np.min(visy),np.max(visy)+(np.max(visy)*0.1))

    # Plot for PROFESSOR
    # Plot the blackbody spectrum in the top subplot
    ax1p.plot(wavelengths, intensities, color='black')
    ax1p.set_title('Student: {}. Figure 1 - Spectrum at {}K'.format(student[0],temperature))
    ax1p.set_xlabel('Wavelength (nm)')
    ax1p.set_ylabel('Intensity') # (W/sr/m^3)
    ax1p.grid(True)
    ax1p.set_xticks(np.arange(min(wavelengths)-1, max(wavelengths), 200))
    # Annotate the plot with the wavelength of peak intensity
    ax1p.annotate('Peak at {:.2f} nm'.format(wavelength_peak),
            xy=(wavelength_peak, np.max(intensities)),
            xytext=(wavelength_peak + 100, np.max(intensities) - 0.5),
            arrowprops=dict(facecolor='black', arrowstyle='->'))

    ax2p.plot(wavelengths,intensities,color='black')
    ax2p.set_title('Student: {}. Figure 2- Absorption pattern for {}, {}, {}'.format(student[0],random_Lines[0],random_Lines[1],random_Lines[2]))
    ax2p.set_xlabel('Wavelength (nm)')
    ax2p.set_ylabel('Intensity')
    ax2p.set_xlim([390,710])
    ax2p.grid(True)
    ax2p.set_ylim(np.min(visy),np.max(visy)+(np.max(visy)*0.1))

    # return the two PDF objects, for writing to file
    return figStudent,figProfessor

def startScript(**kwargs):
    '''
    Function to get the program moving. Not sure if this is the best way
    '''
    # Read in the file of students, one spectrum will be created for each entry
    file=open(kwargs['file'],"r")
    studentList=list(csv.reader(file,delimiter=","))
    file.close()

    # Grabbing the desired output filename
    # outFileName=kwargs['out']

    # Set output PDFs, based on the desired root/suffic name
    # pdfStudent=PdfPages('STUDENT_'+outfileName)
    # pdfProfessor=PdfPages('ANSWERS_'+outfileName)

    # Instantiate two new PDF documents
    pdfStudent=PdfPages('STUDENT_nats1740a-y23-project2-student-spectra.pdf')
    pdfProfessor=PdfPages('ANSWERS_nats1740a-y23-project2-professor-answers.pdf')


    for i in range(len(studentList)):
        figStudent,figProfessor=createSpectrum(studentList[i])
        pdfStudent.savefig(figStudent)
        pdfProfessor.savefig(figProfessor)

    pdfStudent.close()
    pdfProfessor.close()


#-------------------------------------------------------------------------------
#reading in from the command line

parser=argparse.ArgumentParser()
parser.add_argument('file', type=str, help='/path/to/list/of/students. Must be a CSV file, with column 1: student number, column 2: last name, column 3: first name. More columns are fine, they wont be used.')
parser.add_argument('-out', type=str, default='randomStarSpectra.pdf', help="Two output files are always created, with prefixes 'ANSWERS_' and 'STUDENT_'. This argument allows you to specify the root/suffix of those two PDFs. The default is: randomStarSpectra.pdf")
kwargs=vars(parser.parse_args())

startScript(**kwargs)
